// $t@$h
using System;
using System.Diagnostics;
using System.IO;
using Microsoft.Win32;
using System.Windows.Forms;
using LanguageDetection;
using System.IO.Packaging;

public class MalwareDetectionApp {
  [STAThread]
  static void Main() {
    Application.EnableVisualStyles();
    Application.SetCompatibleTextRenderingDefault(false);

    var result = MessageBox.Show("This script checks for potential malware related to CVE-2023-38831.\n\n\
                   WILL NOT MODIFY anything on your machine. Do remediation yourself.\n\n\
                   Source code: https://github.com/STashakkori/MalwareDetection/blob/main/CVE-2023-38831\n\
                   Would you like to run?", "Malware Detection", MessageBoxButtons.YesNo, MessageBoxIcon.Information);

    if (result == DialogResult.Yes) {
      runWinRARCheck();
      chooseDirectoryAndScanDocxFiles();
    }
  }

  static void runWinRARCheck() {
    string winrarPathKey = @"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\WinRAR.exe";
    var winrarPath = Registry.LocalMachine.OpenSubKey(winrarPathKey)?.GetValue("")?.ToString();

    if (winrarPath != null && File.Exists(winrarPath)) {
      var versionInfo = FileVersionInfo.GetVersionInfo(winrarPath);
      string installedVersion = versionInfo.FileVersion;
      Version requiredVersion = new Version("6.23");

      if (new Version(installedVersion) < requiredVersion) {
        MessageBox.Show($"WinRAR update required. Current version: {installedVersion}, Minimum version: {requiredVersion}.", "WinRAR Version Check", MessageBoxButtons.OK, MessageBoxIcon.Warning);
      }
      else {
        MessageBox.Show($"WinRAR version is up to date. Installed version: {installedVersion}.", "WinRAR Version Check", MessageBoxButtons.OK, MessageBoxIcon.Information);
      }
    }
    else {
      MessageBox.Show("WinRAR is not installed on this system.", "WinRAR Version Check", MessageBoxButtons.OK, MessageBoxIcon.Information);
    }
  }

  static void chooseDirectoryAndScanDocxFiles() {
    using (FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog()) {
      folderBrowserDialog.Description = "Select a directory to scan for .docx files:";
      DialogResult dialogResult = folderBrowserDialog.ShowDialog();

      if (dialogResult == DialogResult.OK && !string.IsNullOrWhiteSpace(folderBrowserDialog.SelectedPath)) {
        scanDocxFiles(folderBrowserDialog.SelectedPath);
      }
    }
  }

  static bool hasSketchyExtension(string filePath)
  {
    string pattern = @"\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$";
    return Regex.IsMatch(filePath, pattern);
  }

  static void scanDocxFiles(string directoryPath) {
    var detector = new LanguageDetector();
    detector.AddAllLanguages();
  
    string[] docxFiles = Directory.GetFiles(directoryPath, "*.docx", SearchOption.AllDirectories);
      
    foreach (var file in docxFiles) {
      string fileContent = extractTextFromDocx(file);
      string detectedLanguage = detector.Detect(fileContent);
      bool containsMacros = checkForMacros(file);

      string message = $"File '{file}' scanned.";

      if (HasSuspiciousExtension(file)) { message += " Wacky file extension found!!!!!!!!!"; }

      if (detectedLanguage == "ru") { message += " Contains Russian language!!!!!"; }
      
      if (containsMacros) { message += " Contains macros!!!!!"; }

      if (!containsMacros && detectedLanguage != "ru") { message += " No Russian text or macros found."; }

      MessageBox.Show(message, "File Scan", MessageBoxButtons.OK, MessageBoxIcon.Information);
    }
  }

  static bool checkForMacros(string filePath) {
    try {
      using (Package package = Package.Open(filePath, FileMode.Open, FileAccess.Read)) {
        return package.PartExists(new Uri("/word/vbaProject.bin", UriKind.Relative));
      }
    }
    catch { return false; }
  }

  static string extractTextFromDocx(string filePath) {
    using (Package package = Package.Open(filePath, FileMode.Open, FileAccess.Read)) {
      PackagePart documentXmlPart = package.GetPart(new Uri("/word/document.xml", UriKind.Relative));
      using (StreamReader reader = new StreamReader(documentXmlPart.GetStream())) { return reader.ReadToEnd(); }
    }
  }
}
